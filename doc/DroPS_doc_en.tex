\documentclass[12pt, a4paper]{ctexart} 

\usepackage{geometry}
\usepackage{graphicx}
\usepackage[english]{babel}
\usepackage{color}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{tcolorbox}
\usepackage{listings}

\def\physrep{Physics Reports}
\def\aap{Astronomy \& Astrophysics}
\def\aj{Astronomical Journal}
\def\apjl{Astrophysical Journal Letters}
\def\apjs{Astrophysical Journal Supplement Series}
\def\mnras{MNRAS}
\def\jcap{JCAP}
\def\prd{Physical Review D}
\def\prl{Physical Review Letters}
\def\apj{Astrophysical Journal}
\def\nar{New Astronomy Reviews}
\def\na{New Astronomy}
\def\nat{Nature}

\def\tbox#1{\begin{tcolorbox}#1\end{tcolorbox}}
\def\dsymb{~\mathrm{d}}
\geometry{a4paper, left=2.5cm, right=2.5cm, top=2.5cm, bottom=2.5cm} 


\graphicspath{{figures/}}

\pagestyle{headings}
\usepackage[colorlinks, linkcolor=blue, urlcolor=blue, citecolor=blue]{hyperref}

\begin{document}
\thispagestyle{empty}
\title{\Huge \textbf{DroPS}  \\ \huge {\color{blue}D}eriving {\color{blue} $r$} fr{\color{blue}o}m {\color{blue}P}ower {\color{blue}S}pectra}
\author{Zhiqi Huang \\
huangzhq25@mail.sysu.edu.cn}
\date{November 2025} 
\maketitle 

\thispagestyle{empty} 
\newpage

\tableofcontents
\newpage 

\section{Introduction}


\subsection{Primordial power spectra}
According to the standard cosmological model, the cosmic microwave background (CMB) and the large-scale structure of the universe originated from tiny, nearly Gaussian metric fluctuations in the primordial universe. At linear order, these primordial metric fluctuations can be decomposed into scalar, vector, and tensor modes. Vector perturbations decay rapidly and are therefore generally assumed to be negligible. The primordial scalar and tensor perturbations are respectively parameterized by the dimensionless scalar power spectrum $\mathcal{P}_S(k)$ and tensor power spectrum $\mathcal{P}_T(k)$, where $k$ denotes the comoving wavenumber.

Guided by slow-roll inflation models, the primordial power spectra are commonly parameterized as
\begin{equation}
\mathcal{P}_S(k) = A_s \left(\frac{k}{k{\mathrm{pivot}}}\right)^{n_s - 1},
\end{equation}
and
\begin{equation}
\mathcal{P}_T(k) = r A_s \left(\frac{k}{k{\mathrm{pivot}}}\right)^{n_t}.
\end{equation}
The scalar amplitude $A_s$ and spectral tilt $n_s$ have been tightly constrained by CMB experiments~\cite{Planck18Params}. In most viable inflationary scenarios, the tensor tilt $n_t$ is very small; it is typically either fixed to zero or set to the slow-roll prediction $n_t = -r/8$. The tensor-to-scalar ratio $r$ at the pivot scale, however, remains poorly measured. As of this writing, the best 95\% confidence-level (CL) upper limit is $r < 0.032$~\cite{Tristram22}. A broad range of inflationary models remains consistent with $0 < r < 0.032$~\cite{Inflation23}.  

\subsection{CMB B-polarization and $r$}

The search for the signature of primordial gravitational waves in CMB, i.e., measuring $r$ from CMB is one of the most compelling pursuits in modern cosmology. This quest focuses on a unique observable: the B-mode polarization pattern.

The CMB photons became polarized when they scattered off free electrons in the early universe. This process imprinted a directional preference on the light, creating two distinct patterns: E-modes, which have a curl-free pattern like the electric field around charges, and B-modes, which have a curl-like pattern. While density fluctuations (scalar perturbations) in the primordial plasma can generate E-modes and a small amount of B-modes through gravitational lensing (so-called lensing B-modes), they cannot produce the specific, large-scale curl-like pattern of primordial B-modes.

This is where primordial gravitational waves come in. These waves, theorized to be generated during the inflationary epoch, are literally ripples in the fabric of spacetime. As they propagated through the early universe, they periodically stretched and squeezed space, imparting a unique, curl-like distortion to the plasma. This gravitational tugging created a polarization pattern in the CMB that is fundamentally rotational in nature—the primordial B-mode polarization.

Therefore, the B-mode power spectrum at large angular scales acts as a direct tracer for these primordial gravitational waves. A confident detection of this primordial B-mode signal would be tantamount to detecting the gravitational waves themselves. Its amplitude is directly proportional to the energy scale of inflation, with the tensor-to-scalar ratio $r$ quantifying the strength of the signal. Measuring this B-mode power spectrum thus provides a unique window into the physics of the universe's first moments and the grand unification of gravity and quantum mechanics.

\subsection{Ground-based CMB experiments with small-aperture telescopes}


A key objective of many ground-based, small-aperture telescope (SAT) CMB experiments—including BICEP/Keck~\cite{BICEP}, AliCPT~\cite{AliCPT, Zhang24, AliCPT25}, the Simons Observatory SATs~\cite{SO-SAT, SO-SAT-improve}, and the initially planned CMB-S4 SATs~\cite{CMB-S4-Intro, CMB-S4-SAT}\footnote{At the time of writing, unfortunately CMB-S4 is no longer financially supported.}—is to measure the degree-scale CMB B-mode polarization, the unique signature of primordial gravitational waves. These telescopes observe the polarized sky emission across a wide frequency range (typically ~30–300 GHz), where the raw data is a complex mixture of the CMB signal, pervasive Galactic foregrounds, atmospheric emission, and instrumental noise. Disentangling the faint primordial B-mode signal from these dominant contaminants presents a significant data challenge, necessitating sophisticated component-separation and analysis software. Our software, DroPS, is designed specifically to meet this need, providing a robust framework for inferring the tensor-to-scalar ratio $r$ from the polarization data acquired by ground-based SATs.


\newpage

\section{Software Documentation}

Designed for efficiency, DroPS has minimal hardware requirements. The analyses presented in this documentation were performed efficiently on a conventional laptop. A typical setup for running DroPS is a standard personal computer with a few hundred gigabytes of free storage.

\subsection{Installing DroPS}

While this guide has been tested on Ubuntu 24.04 LTS, the process is generally straightforward on other Linux distributions. For Windows and macOS users, some steps may require slight modifications, particularly regarding environment setup or package installation.

\subsubsection{Installing tools and libraries}

Install the following packages and libraries with Synaptic Package Manager or ``sudo apt install'':

\begin{itemize}
  \item{git}
  \item{gcc}
  \item{gfortran}
  \item{cmake}
  \item{python3-pip}
  \item{python-is-python3}
  \item{python3-venv}
  \item{openmpi-dev}
  \item{libxcb-cursor0}
  \item{libcfitsio-dev}
  \item{libgsl-dev}
  \item{libfftw3-dev}
  \item{libfftw3-mpi-dev}
  \item{libhealpix-dev}
\end{itemize}

\subsubsection{Set up a Python virtual environment}

Create a directory for Python virtual environment in your work path (hereafter denoted as YourWorkPath)
\tbox{mkdir YourWorkPath/.work}

Create the Python virtual environment
\tbox{python  -m  venv YourWorkPath/.work}

Activate the virtual environment
\tbox{source YourWorkPath/.work/bin/activate}
On windows you may need to run
\tbox{YourWorkPath/.work/Scripts/activate.bat}
in cmd.exe or
\tbox{YourWorkPath/.work/Scripts/activate.psl}
in PowerShell.

When you are done with your work, exit the terminal or use
\tbox{deactivate}
to exit the virtual environment.

If you are not working with other Python projects. You may want to activate the virtual environment automatically with the terminal 
\tbox{echo ``source YourWorkPath/.work/bin/activate''\ \ $>>$\ \ \$\{HOME\}/.bashrc}

\subsubsection{Install requirements}


Activate the virtual environment either manually or automatically as described in the previous subsection.

Upgrade pip for the latest information of packages:
\tbox{pip install -\,-upgrade pip}

Now enter your work path where you want to install DroPS
\tbox{cd YourWorkPath}
Get the DroPS repository
\tbox{git clone https://github.com/zqhuang/DroPS}

Now enter the DroPS directory
\tbox{cd DroPS}
Install all dependencies
\tbox{pip install -r requirements.txt}

\subsubsection{Hacking pysm3}

While hacking a Python package is generally not recommended, we have made a pragmatic choice to do so for significant gains in the efficiency of large-scale CMB simulations. Note that this step is entirely optional and is only required for simulation work; users who solely wish to analyze existing sky maps can safely skip it.


Enter the DroPS directory
\tbox{cd YourWorkPath/DroPS}
Move the cmb.py file in the pysm3 package to somewhere else
\tbox{mv PATH\_TO\_pysm3/models/cmb.py cmb\_backup.py}
and replace it with the cmb.py file that comes with DroPS
\tbox{cp cmb.py PATH\_TO\_pysm3/models/}
Here PATH\_TO\_pysm3 stands for the path where pysm3 was installed. On Ubuntu 24.04.3LTS, you may find PATH\_TO\_pysm3 to be

YourWorkPath/.work/lib/python3.12/site-packages/pysm3

If you are not using Ubuntu24.04.3LTS, the pysm3 path may be slightly different. You can find out the path by doing
\tbox{sudo apt install plocate}
and
\tbox{locate pysm3}


\subsection{Base simulations}

    Before analyzing real or simulated sky maps, it is necessary to first generate the base simulations—a set of simulated CMB, noise, and foreground components. These simulations represent our best-informed model of reality, encapsulating our current understanding of the cosmology, instrument, noise, and foregrounds. As such, they serve a role analogous to ``training data'' in machine learning\footnote{Note that this is purely a conceptual analogy; DroPS does not employ ML techniques.}. Nevertheless, systematic offsets may persist between these simulations and the actual observations.

\subsubsection{Generate a TOD filtering model}

A critical step in processing data from ground-based CMB experiments is the mitigation of ground and atmospheric contamination in the time-ordered data (TOD). Accurately simulating this filtering process necessitates detailed knowledge of the survey strategy, which is often unavailable during the forecasting stage. Fortunately, the overall effect is well-understood: it suppresses large-scale power (low multipoles) in the final maps and introduces non-Gaussian correlations by mixing Fourier modes. For use cases that do not require a precise, survey-specific simulation, DroPS provides a "mock filtering" tool to generate an approximate filtering matrix.

To generate the TOD filtering matrix, run:
\tbox{python mock\_filtering.py}
and follow the prompts. Enter the healpix resolution (nside, 128 for testing, 256/512 for serious simulations) and the file name for the filtering matrix (e.g. filter\_128.pickle). You may also refine the model by entering the parameters $\ell_{\rm cut}$, $f_{\rm low}$, $f_{\rm high}$, $\alpha_{\rm low}$, $\theta_\ell$, $\theta_m$ that are defined in Sec.~\ref{sec:TOD}. 


\subsubsection{Generating base simulations}

Now we are ready to generate the base simulations for given experiments.  DroPS comes with four ``demo-experiments'': Test, AliCPT, SO, and CMBS4.  The ``Test'' demo-experiment is just for testing purpose and does not have a counterpart in reality. The configurations (sky coverage, noise level etc., see Table~\ref{tab:config}) of the latter three demo-experiments (AliCPT, SO, CMBS4) are similar, but not identical to their counterparts in reality (AliCPT~\cite{AliCPT}, SO-SAT~\cite{SO-SAT} and CMB-S4-SAT~\cite{CMB-S4-SAT}). In this documentation we will mainly use the ``AliCPT'' experiment as examples. We will also use SO for comparison between different foreground modeling and between DroPS and other pipelines in the literature~\cite{SO-SAT}.

\begin{table}
  \centering
  \caption{Key configurations of DroPS demo-experiments; $\ell_{\rm knee}$ and $\alpha_{\rm knee}$ are defined in Sec.~\ref{sec:noise} \label{tab:config}}
  \begin{tabular}{l|lllll}
    \hline
    \hline
    & frequency & beam FWHM & noise-level $\sigma_{\rm white}$  & $\ell_{\rm knee}$ & $\alpha_{\rm knee}$ \\
    & (GHz) & (arcmin) & ($\mathrm{\mu K}$-arcmin) & & \\
    \hline
  Test   & $30$  & $60$ & $1$ & $60$ & $-1.7$ \\
  ($f_{\rm sky}\approx 0.1$) & $95$  & $20$ & $1$ & $60$ & $-1.7$ \\
         & $150$ & $20$ & $1$ & $60$ & $-3$ \\
         & $270$ & $10$ & $1$ & $60$ & $-3$ \\
  \hline
  AliCPT & $27$  & $97$   & $47$  &  $30$ & $-2.4$ \\
  ($f_{\rm sky}\approx 0.14$) & $40$  & $65$   & $34$  &  $30$ & $-2.4$ \\
         & $90$  & $16.2$ & $2.2$ &  $50$ & $-2.5$ \\
         & $150$ & $9.7$  & $3.3$ &  $50$ & $-3$ \\
    {\scriptsize (+Planck)}& $217$ & $4.9$  & $50$  &   $0^+$    & $-3$  \\
  \hline
  SO & $27$ & $91$ & $33$ & $15$ & $-2.4$ \\
  ($f_{\rm sky}\approx 0.1$) & $39$ & $63$ & $22$ & $15$ & $-2.4$ \\
  & $93$ & $30$ & $2.5$ & $25$ & $-2.5$ \\
  & $145$ & $17$ & $2.8$ & $25$ & $-3$ \\
  & $225$ & $11$ & $5.5$ & $35$ & $-3$ \\
  & $280$ & $9$ & $14$ & $40$ & $-3$ \\
  \hline
  CMBS4 & $30$ & $72.8$ &  $2.5$ & $60$ & $-1.7$ \\
  ($f_{\rm sky}\approx 0.1$) & $40$ &  $72.8$ & $3.15$ & $60$ & $-1.7$ \\
  & $85$  & $25.5$ & $0.622$ & $60$ & $-1.7$ \\
  & $95$  & $22.7$ & $0.552$ & $60$ & $-1.7$ \\
  & $145$ & $25.5$ & $0.87$ &  $60$ & $-3$ \\
  & $155$ & $22.7$ & $0.948$ & $60$ & $-3$ \\
  & $220$ & $13$ & $2.46$ & $60$ & $-3$ \\
  & $270$ & $13$ & $4.22$ & $60$ & $-3$ \\
  \hline
  \end{tabular}
\end{table}

To begin with, you can simulate noise/cmb/foreground maps for the demo-experiment AliCPT.

\tbox{python simulate.py AliCPT/AliCPT\_sim\_config.txt}
Compare the content of configuration file AliCPT/AliCPT\_sim\_config.txt with Table~\ref{tab:config} to understand how the configurations are passed to the script. When no other command-line arguments are passed to simulate.py, it only produces base simulations, that are, a lot of realizations of noise and CMB maps based on the noise model and cosmology that are specified in the configuration file. The foreground maps are only produced once, as we do not yet have a reliable model to describe the ``cosmic variance'' of foreground emissions.
By default, the base simulations use the foreground model ['d0', 's0'] with fixed spectral indices ($\beta_d=1.54$ for thermal dust, $\beta_s=-3$ for synchrotron). This ['d0', 's0'] foreground map only captures the gross feature of the Galactic emission. The ``actual foreground'' that we will analyze in the next section can be different from the one used in the base simulations. A robust $r$ measurement pipeline must be insensitive to the finer details of the foreground modeling.

To further understand how the foreground models are defined in pysm3, you may follow its documentation at \url{https://pysm3.readthedocs.io/}. 

\subsection{Analyzing the sky maps}

In the previous section, we generated a set of base simulations. These serve as a reference library, constructed from a specific noise model, the foreground model ['d0', 's0'], and a set of fiducial $r$ values within a $\Lambda$CDM cosmology. Now we can simulate an "observed sky" map. This mock observation uses the same noise model but can employ a different foreground model and, crucially, an $r$ value that is independent of those in the base simulations. DroPS will determine the value of $r$ in this "observed sky" by statistically comparing it against the base simulation library. Conceptually, this "observed sky" is analogous to a ``test sample'' in machine learning. We may also generate many realizations of the ``observed sky'' to assess the average offset (bias) between the reconstructed and input $r$ values.

\subsubsection{Analyzing one realization of sky}

Generate the ``observed sky'' with, e.g.,
\tbox{python simulate.py AliCPT/AliCPT\_sim\_config.txt maps/AliCPT\_  0.01 999}

You can replace maps/AliCPT\_ with your preferred prefix for the output maps, $0.01$ with your preferred fiducial $r$ value, and $999$ with your preferred random seed. To test whether DroPS can deal with a spatial variation of the foreground, you may also replace the ['d0', 's0'] foreground model with, e.g., ['d1', 's1'] in the configuration file AliCPT/AliCPT\_sim\_config.txt.

Now analyze the ``observed sky'' with
\tbox{python mainpipe.py AliCPT/AliCPT\_ana\_config.txt maps/AliCPT\_}
Read the configuration file AliCPT/AliCPT\_ana\_config.txt to understand how to analyze the maps with different settings.

The summary statistics of $r$ and other parameters will be shown on the screen when the analysis is done. More detailed results will be saved in AliCPT/results, a path that is also specified in the configuration file AliCPT/AliCPT\_ana\_config.txt.

\subsubsection{Analyzing multiple realizations of sky}

In one simulation, the posterior mean value of $r$ can be above or below the input $r$, and this depends on the random seed. To test whether the $r$-measurement pipeline is biased or not, we need to apply the pipeline on many simulations with different random seeds.

This time we choose a different foreground model [``d1'', ``s1'']. Now run the simulations and analyze them by running the following shell script (test\_bias.sh in the repository)

\tbox{./test\_bias.sh}

The content of test\_bias.sh is shown below.

\begin{tcolorbox}
  \begin{minipage}{0.95\textwidth}
    \begin{scriptsize}
      \begin{lstlisting}[language=bash, caption={content of test\_bias.sh}]
for i in `seq 100` 
do 
    python simulate.py AliCPT/AliCPT_sim_config.txt maps/s${i}_  0.01 ${i}  d1s1  
    python mainpipe.py AliCPT/AliCPT_ana_config.txt maps/s${i}_ logfile.txt
done
      \end{lstlisting}
    \end{scriptsize}
\end{minipage}
\end{tcolorbox}
Here $0.01$ is the fiducial $r$ value; the random seed (bash variable \$\{i\}) runs from 1 to 100; maps/s\$\{i\} is the root name (prefix for output files) for each simulation; logfile.txt is the file that saves the reconstructed means and standard deviations of $r$.

Now plot the saved means and standard deviations of $r$ from logfile.txt, and compare them with the input $r=0.01$.
\tbox{python utils/plot\_rs.py logfile.txt 0.01}

If the bias of $r$-measurement is small, the mean of reconstructed mean values of $r$ (dotted blue line) is supposed to be close to the fiducial value (solid orange line), as shown in Figure~\ref{fig:r_logs}.

\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{r1_logfile_d1s1.png}
  \caption{Reconstructed $r$ for 100 realizations of sky with different random seeds. For each sky, the $r$ value is reconstructed by comparing the sky with 300 base simulations. The 100 realizations of sky are simulated with foreground model ['d1','s1'] (spatially varying SED of synchrotron and dust emission), while  ['d0', 's0'] (fixed SED) is used in the 300 base simulations. \label{fig:r_logs}}
\end{figure}


\subsubsection{How to apply on real data}

A real experiment comes with its own map making and noise simulation pipelines, and provides base simulations and the actually observed sky maps. To analyze the real data, you can simply replace the base simulations with the maps from the simulation pipeline of the experiment, and replace the realization of sky with the actually observed frequency maps.


\subsubsection{Comparison with other pipelines}

DroPS has been applied on AliCPT data challenge (simulated 14\% sky, 95GHz and 150GHz) and achieved consistent results with other methods~\cite{Zhang24}. Here we further compare DroPS with three pipelines that have been applied on simulation data of SO-SAT (Wolz et al. 2024~\cite{SO-SAT}). We adopt the optimistic configuration of SO-SAT. The input fiducial $r$ is zero, and in the analyses unphysical negative $r$ is allowed\footnote{in DroPS this is realized by setting r\_lowerbound negative in the configuration file}.  The results are shown in Figure~\ref{fig:compare_SO}.  From top to bottom, foreground models ['d0', 's0'], ['d1', 's1'], and ['dm', 'sm'] are used, respectively\footnote{The model ['dm', 'sm'] does not come with pysm3 and needs to be prepared by the user. See~\cite{SO-SAT} for its definition.}. From the left where the reconstructed means of $r$ and the bias (mean of the reconstructed means of $r$) are shown, we find DroPS has negligible biases for all cases and more stable than the three pipelines tested in Wolz et al. The right column shows $\sigma_r$, the statistical uncertainties in $r$. We again find good consistency between DroPS and the other pipelines. 

\begin{figure}
  \includegraphics[width=0.5\textwidth]{d0s0_mean.png}%
  \includegraphics[width=0.5\textwidth]{d0s0_std.png}
  \includegraphics[width=0.5\textwidth]{d1s1_mean.png}%
  \includegraphics[width=0.5\textwidth]{d1s1_std.png}
  \includegraphics[width=0.5\textwidth]{dmsm_mean.png}%
  \includegraphics[width=0.5\textwidth]{dmsm_std.png}
  \caption{Comparing DroPS with three pipelines that are described in Wolf et al.~\cite{SO-SAT}. From top to bottom, foreground models ['d0', 's0'], ['d', 's1'], and ['dm', 'sm'] are used, respectively. Left and right columns are the distribution of reconstructed mean $r$ and $\sigma_r$, respectively.\label{fig:compare_SO}}
\end{figure}

\subsection{Map-level Operations}

\subsubsection{Likelihood-based component separation}

The most well known method of component separation is probably the internal linear combination (ILC) algorithm and its variations. The basic idea is to isolate a signal - whose frequency dependence is known - by taking linear combination of the frequency maps. To do that in pixel space, the frequency maps have to be smoothed to a common resolution. 

For ground-based CMB experiments, however, a key challenge of ILC or ILC-like methods is that TOD filtering and beam convolution are non commutative operations. Consequently, smoothing frequency maps to a common resolution inevitably alters their spectral energy distributions. This inherent limitation explains why, despite its popularity in simulations that neglect TOD filtering effects~\cite{SO-SAT}, ILC is often superseded by more computationally intensive, likelihood-based methods in real-world analyses, such as those conducted by BICEP/Keck~\cite{BKmap}.

DroPS also provides a map-level component separation code. To demonstrate how the code works, we generate a sky realization from the base simulation \#0:
\tbox{{\small python utils/combine\_sim.py AliCPT/AliCPT\_sim\_config.txt maps/r3AliCPT0\_  0}}
The above script takes the base simulation \#0 and adds the filtered foreground maps, filtered noise maps and filtered CMB maps into sky frequency maps with root name maps/r3AliCPT0\_.

Now we do component separation
\tbox{ python compsep.py AliCPT/AliCPT\_sim\_config.txt maps/r3AliCPT0\_}

The code uses Stochastic Gradient Langevin Dynamics (SGLD) method to search the maximum of the likelihood described in Sec.~\ref{sec:sgld_like}. It typically takes a few days to run compsep.py for the first time, on a personal computer. When the gradient templates are built, the code runs much faster, typically takes only a few hours on a personal computer. Typically you need to run it multiple times to obtain a well converged CMB B-mode map. Figure~\ref{fig:compsep} shows the result for the maps simulated with AliCPT/AliCPT\_sim\_config.txt. The $E$ maps are recovered very well. While significant residual noises remain in the $B$ maps.

\begin{figure}
  \includegraphics[width=0.5\textwidth]{AliCPT_original_Emap.png}%
  \includegraphics[width=0.5\textwidth]{AliCPT_reconstructed_Emap.png}    
  \includegraphics[width=0.5\textwidth]{AliCPT_original_Bmap.png}%
  \includegraphics[width=0.5\textwidth]{AliCPT_reconstructed_Bmap.png}  
  \includegraphics[width=0.5\textwidth]{AliCPT_original_Bmap_l30.png}%
  \includegraphics[width=0.5\textwidth]{AliCPT_reconstructed_Bmap_l30.png}
  \includegraphics[width=0.5\textwidth]{FG_original_Bmap.png}%
  \includegraphics[width=0.5\textwidth]{FG_reconstructed_Bmap.png}  
  \caption{Component separation for maps simulated with AliCPT/AliCPT\_sim\_config.txt. All maps are smoothed with top-hat low-pass filter at $\ell\le 160$. \label{fig:compsep}}
\end{figure}

For real data analyses, the calculation of gradient template involves map making and therefore takes even longer time to built. Fortunately, the gradient template can be built in a parallel way. The template can be built for $\ell \in [\ell_{\min}, \ell_{\max}]$ by running
\tbox{{\small python compsep.py AliCPT/AliCPT\_sim\_config.txt maps/r3AliCPT0\_ lmin lmax}}
Thus, with parallel I/O that is commonly supported in modern architectures, the task can be decomposed into many sub-tasks with different lmin and lmax. You need $\sim$100GB disk space to store all the gradient templates.



\subsubsection{Displaying the maps}

DroPS provides a few tools to display the maps on the screen.

The script utils/viewfits.py displays the fits maps.

\tbox{python utils/viewfits.py NHmask\_G\_128.fits}

If you have a map example\_IQU.fits with stokes I, Q, U components, you can run
\tbox{python utils/viewfits.py example\_IQU.fits mapind}
with mapind = 0, 1, 2 for I, Q, U components, respectively.


DroPS often saves partial-sky maps in npy format. Now suppose the mask file is mask.fits. To display these masked-sky maps, use utils/viewnpy.py:

\tbox{python utils/viewnpy.py mask.fits example\_IQU.npy mapind}
with mapind = 0, 1, 2 for I, Q, U components, respectively.

To display E/B components, use utils/viewEB.py:
\tbox{python utils/viewEB.py mask.fits example\_IQU.npy E/B}


\newpage

\section{Technical Details}

In this section I assume the reader has cosmological background and is familiar with Healpix~\cite{Healpix}.


DroPS analyzes the power spectrum by dividing the multipole range into a few bins and computing the band powers\footnote{A band power represents the average power spectrum within a given $\ell$ bin.} for masked maps using NaMaster~\cite{NaMaster}. For measuring the tensor-to-scalar ratio $r$, the analysis typically focuses on the range $20 \lesssim \ell \lesssim 200$ with a small number of bins. A resolution of nside = 256 is sufficient for this purpose, while nside = 128 may be adequate for quick estimates. However, caution is advised when performing operations such as changing the map resolution or rotating to a different coordinate system, as these can introduce significant E-to-B leakage in low-resolution maps. For any analysis involving these manipulations, we recommend using a higher resolution of nside = 512.

The data vector for the likelihood analysis consists of the band powers derived from the filtered sky maps. These are constructed as follows: band powers between different frequency channels are computed directly as cross-power spectra, while for a single channel, they are obtained from the cross-power of pairs of independent season maps within that channel. This design ensures that the expectation value of the noise band power is zero in all cases, which effectively eliminates bias from imperfect noise modeling. This approach represents a standard in modern CMB analysis.


Let $n_{\rm bin}$ be the number of $\ell$-bins, $n_\nu$ the number of frequency channels, and $n_{\rm fld}$ the number of fields (e.g., TT, TE, EE, BB). The data vector comprises the band powers $D^{XY}_\ell(\nu_1,\nu_2)$, indexed by:
 \begin{itemize}
 \item{Multipole bin centered at $\ell$;}
 \item{Field $XY$;}
 \item{All ranked frequency pairs $(\nu_1, \nu_2)$ with $\nu_1 \le \nu_2$.}
 \end{itemize}
 As noted previously, for $\nu_1 = \nu_2$, the band power is computed by averaging over season-map cross-spectra. The total number of ranked frequency pairs is $n_\nu(n_\nu+1)/2$, making the full data vector length $N_d = \frac{1}{2} n_{\rm fld} n_{\rm bin} n_\nu (n_\nu+1)$. For $r$-measurement with limited computing or storage resources, we recommend using only the $BB$ spectra ($n_{\rm fld}=1$), as they contain nearly all the information on $r$.

 The fundamental approach is to evaluate the likelihood of the observed data vector $D^{XY}_\ell(\nu_1,\nu_2)$ (abstractly written as $D^{\rm obs}$) given a model prediction  (abstractly written as $D^{\rm model}$). Taking a Gaussian approximation, the likelihood is:
 \begin{equation}
   \mathcal{L} = \frac{1}{(2\pi)^{N_d/2}\sqrt{\det\mathbf{\Sigma}}} \exp\left[-\frac{1}{2}(\mathbf{D}^{\rm obs} - \mathbf{D}^{\rm model})^T \mathbf{\Sigma}^{-1} (\mathbf{D}^{\rm obs} - \mathbf{D}^{\rm model})\right],
 \end{equation}
 The model is constructed from the signal components:
 \begin{equation}
   \mathbf{D}^{\rm model} = \mathbf{D}^{\rm CMB} + \mathbf{D}^{\rm fg},
 \end{equation}
 where $D^{\rm CMB}$ and $D^{\rm fg}$ are the expected band powers from the CMB and foregrounds. The noise expectation is zero due to the exclusive use of cross-correlations. The total covariance $\mathrm{Cov}$ encompasses all variance from noise, foregrounds, and CMB.


 Prior to discussing the specific noise, CMB, and foreground models or the technical estimation of $\mathrm{Cov}$, we will outline two key components: the map-making simulators for the base simulations, and how the TOD filtering is modeled throughout the pipeline. 



\subsection{TOD filtering and map making \label{sec:TOD}}

 A critical preprocessing step in ground-based CMB experiments is the TOD filtering, which isolates the faint CMB signal from dominant, structured ground noise. Observations from the ground are heavily contaminated by low-frequency noise from atmospheric emission and instrumental $1/f$ noise. TOD filtering operates in the time domain to identify and subtract these systematic contaminants, which often exhibit characteristic temporal or scan-synchronous patterns distinct from the CMB. By applying high-pass or more sophisticated modal filters, it suppresses large-scale noise while aiming to preserve the intrinsic CMB signal, enabling the production of high-fidelity sky maps.

Although a linear process, TOD filtering is equivalent to applying a dense matrix that is difficult to model without detailed knowledge of the experiment's scanning strategy. Consequently, DroPS does not include full map-making pipelines for specific experiments. Instead, it provides streamlined ``map-making'' simulators. These simulators approximate the net effect of the pipeline by combining a few linear operations in both pixel and harmonic space, guided by the survey mask and a handful of parameters that capture the essential features of TOD filtering.

Specifically, the simulator applies the following operations to an input map:
\begin{enumerate}
\item{Generate a filtering matrix (in harmonic space) with six parameters $\ell_{\rm cut}$, $f_{\rm low}$, $f_{\rm high}$, $\alpha$, $\theta_\ell$ and $\theta_m$. Specifically, the matrix is given by $$M_{\ell^\prime m^\prime, \ell m} =
  \left\{\begin{array}{ll}
  \sqrt{\left[1-2\left(\theta_\ell + \theta_m\right)\right] F_\ell}, & \text{if } \ell^\prime = \ell, m^\prime = m; \\
  \sqrt{F_\ell\theta_\ell} G_{\rm random} & \text{if } |\ell^\prime -\ell|=1, m^\prime = m \\
  \sqrt{F_\ell\theta_m} G_{\rm random} & \text{if } \ell^\prime= \ell, |m^\prime - m|= 1 \\  
  0, & \text{else}
  \end{array}\right.$$
  where $$F_\ell \equiv f_{\rm high}\left\{1-f_{\rm low}\exp{\left[-\left(\frac{\ell}{\ell_{\rm cut}}\right)^\alpha\right]}\right\}$$
and $G_{\rm random}$ is a random Gaussian number. For each matrix element $G_{\rm random}$ is drawn independently.}
\item{Generate a smoothed mask by apodizing the mask edges using a C2-type kernel  with an apodization scale of 2 degrees~\cite{Grain09}. }  
\item{PMultiply the input map pixel-wise by the smoothed mask.}
\item{Perform a spherical harmonic transform to obtain harmonic coefficients $a_{\ell m}$.}
\item{Apply the filtering matrix 
$$ a_{\ell^\prime m^\prime} = \sum_{\ell, m} M_{\ell^\prime m^\prime, \ell m} a_{\ell m}.$$}
\item{Perform an inverse spherical harmonic transform back to a map.}
\item{Multiply the resulting map pixel-wise by the original (unapodized) mask.}
\end{enumerate}

When
\tbox{python mock\_filtering}
is called. It generates a pickle file that saves the random numbers ($G_{\rm random}$) in operation 1.

When simulating maps, the pickle file is specified in the configuration file (e.g. AliCPT/AliCPT\_sim\_config.txt). DroPS loads the pickle file and performs ``map making'' (seven linear operations in sequence, as specified above).

The ``map-making'' simulator is designed for computational efficiency, requiring far fewer resources than a full pipeline that processes actual time-ordered data. It is a simplified model whose purpose is not to replicate every detail, but to capture the dominant large-scale effects of TOD filtering—namely, power suppression and mode mixing—for simulation-based studies.

In the analysis stage, DroPS operates without prior knowledge of the specific TOD filtering applied in the simulations. It phenomenologically models the net filtering effect using a coupling matrix $F_{\ell\ell^\prime}$. This matrix is structured such that its main diagonal captures the power suppression in each multipole bin, while the first off-diagonals capture the mode coupling between adjacent bins; all other elements are set to zero. By default, this matrix is calibrated empirically by performing a least-squares fit that compares the band powers of filtered versus unfiltered noise maps from the base simulations.

An important caveat is that while TOD filtering is a linear operation on the map, its effect on the power spectrum is not strictly linear. The band-diagonal coupling matrix $F_{\ell\ell^\prime}$​ is therefore a simplified model. Consequently, the design of DroPS intentionally minimizes reliance on this approximate model to ensure robustness. (See Sec.~\ref{sec:cmb} for more details.)


\subsection{Noise model \label{sec:noise}}

DroPS adopts a noise model for its temperature power spectrum following the established approach in Refs.~\cite{SO2019, SO-SAT}:
\begin{equation}
  N_\ell = N_{\rm white}\left[1+\left(\frac{\ell}{\ell_{\rm knee}}\right)^{\alpha_{\rm knee}}\right]. \label{eq:noise_model}
\end{equation}
Here, the $1/f$ noise component is parameterized by the knee multipole $\ell_{\rm knee}$ and the slope $\alpha_{\rm knee}$. The white noise level $N_{\rm white}$ is derived from the configuration parameter $\sigma_{\rm white}$ (see Table~\ref{tab:config}) as
\begin{equation}
  N_{\rm white} = \sigma_{\rm white}^2, \label{eq:Nwhite}
\end{equation}
where $\sigma_{\rm white}$ must be in units of $\mu$K-radian\footnote{To convert from $\mu$K-arcmin, multiply by a factor of $\frac{\pi}{10800}$.}.

For the demo-experiments, the polarization noise spectra are simplified to $N_\ell^{EE} = N_\ell^{BB} = 2N_{\ell}^{TT}$. While this relation is not exact for real instruments, it provides a reasonable approximation in many cases.

It is important to note that the analytic model in Eq.~\eqref{eq:noise_model} is used exclusively for generating the base simulations. During the data analysis stage, DroPS bypasses this model and computes the noise covariance directly from the base simulations themselves. Furthermore, the expectation value of the noise power spectrum is always zero in the analysis because DroPS exclusively employs cross-power spectra between different frequency channels or observation seasons, thereby inherently deriving noise-debiased power spectra.

    
\subsection{CMB model \label{sec:cmb}}

\subsubsection{Cosmology}

DroPS assumes standard Lambda cold dark matter ($\Lambda$CDM) with an additional parameter $r$. For the demo experiments, the default cosmological parameters for base simulations are listed in Table~\ref{tab:cosmo}. 

\begin{table}
  \centering
  \caption{Default cosmological parameters for base simulations \label{tab:cosmo}}
  \begin{tabular}{lll}
    \hline
    \hline
    parameter & definition & default value \\
    \hline
    $\Omega_bh^2$ & baryon density & $0.02242$ \\
    $\Omega_ch^2$ & cold dark matter density & $0.11933$ \\
    $\theta_{\rm MC}$ & angular extension of sound horizon & $0.0104101$ \\
    $\tau_{\rm re}$  & reionization optical depth & $0.0561$ \\
    $\ln\left(10^{10}A_s\right)$ & logarithm amplitude of primordial scalar power & $3.047$  \\
    $n_s$ & spectral index of primordial scalar power & $0.9665$ \\
    $r$ & tensor-to-scalar ratio & $r_0=0$ or $r_1=0.03$ \\
    \hline
  \end{tabular}
\end{table}

 Unlike the noise statistics, which can be empirically derived from the base simulations, the CMB statistics depend on underlying cosmological parameters—most notably the unknown tensor-to-scalar ratio rr. This fundamental difference necessitates a more sophisticated approach for modeling the CMB band powers and their contribution to the signal covariance matrix.


\subsubsection{Delensing \label{sec:delens}}

    Gravitational lensing by large-scale structure distorts the primordial CMB, smoothing its acoustic peaks and converting a portion of the E-mode polarization into a secondary B-mode signal. This lensing-induced B-mode acts as a dominant foreground on small scales, obscuring the fainter primordial B-modes from inflationary gravitational waves. While the expectation value of this lensing B-mode power can be theoretically predicted and subtracted, the actual lensing potential in our observed Universe randomly fluctuates around this mean—a source of cosmic variance. For measurements targeting an uncertainty of $\sigma_r\lesssim 10^{-3}$, this unpredictable fluctuation becomes a significant contaminant.

    Delensing addresses this by statistically reconstructing the actual lensing distortion from high-resolution CMB data or external tracers and removing its specific imprint from the observed maps. This process cleans the cosmic foreground, sharpens the CMB's original features, and suppresses the confounding lensing B-mode power, thereby dramatically enhancing the sensitivity to primordial signals.

    In DroPS, the implementation assumes that an ideal lensing potential map is available from external sources. While such a map would, in principle, allow for complete delensing, practical limitations prevent perfect removal. To model this, DroPS introduces a delensing efficiency parameter $\epsilon_{\rm delens}$ (delens\_fac in the configuration file), which specifies the fraction of the lensing effect to be removed. Concretely, the process is performed by rescaling the input lensing potential map by a factor of $(1-\epsilon_{\rm delens})$ before applying the delensing operation.
    

\subsubsection{Cosmological parameter inference}

    The primary goal of DroPS is to infer the tensor-to-scalar ratio rr, which is by default the only free cosmological parameter. Users can choose to vary the full set of standard ΛΛCDM parameters by setting vary\_cosmology = True in the configuration file. However, since the large-scale polarization data from ground-base SATs alone provide weak constraints on the background cosmology, DroPS applies a Gaussian prior based on Planck+BAO results~\cite{Planck18Params} to ensure the parameters remain within physically reasonable ranges\footnote{This prior can be disabled by modifying mainpipe.py, but doing so may lead to poor convergence in the Monte Carlo sampling or numerical instability.}.


The base simulations are generated with two fiducial values of the tensor-to-scalar ratio: $r=0$ and $r=r_1>0$. By averaging over these simulations, we obtain the expected CMB band powers, $\langle D^{\rm CMB}_\ell(r=0)\rangle $ and $\langle D^{\rm CMB}_\ell(r=r_1)\rangle$. The recommended value for $r_1$​ is $0.03$ (approximately the current 90\% confidence level upper limit), which is user-configurable.    

Under the standard cosmological model, and assuming other parameters $\theta$ are fixed to their fiducial values $\theta_{\rm fid}$​, the CMB band powers exhibit an approximately linear response to rr. DroPS leverages this by modeling the CMB band powers as a linear interpolation between the two simulated benchmarks, which inherently includes all instrumental effects:
\begin{equation}
  D^{\rm CMB}_\ell =  (1-w) \langle D^{\rm CMB}_\ell(r=0)\rangle  + w\langle D^{\rm CMB}_\ell(r=r_1) \rangle + \Delta_{\rm correction}.
\end{equation}
The interpolation weight $w$ is defined as $w \equiv \max\left[\min\left(\frac{r}{r_1}, 1\right), -1\right]$,  effectively clamping the interpolation for $|r|>r_1$.

The correction term $​\Delta_{\rm correction}$ applies the TOD filtering matrix $F_{\ell\ell^\prime}$ only to the deviation from this fiducial interpolated spectrum:
\begin{equation}
  \Delta_{\rm correction} = \sum_{\ell^\prime} F_{\ell \ell^\prime}\left[D^{\rm CMB}_{\ell^\prime}(r, \theta) - (1-w)D_{\ell^\prime}^{\rm CMB}(r=0, \theta_{\rm fid})- wD_{\ell^\prime }^{\rm CMB}(r=r_1, \theta_{\rm fid})\right],  
\end{equation}
This design is highly efficient for the most likely scenario in next-generation experiments, where $|r|<r_1$ and cosmological parameters are well-constrained. In this case, the term inside the brackets is small, and the filtering matrix—whose model might be approximate—is applied only to a residual, thereby minimizing the impact of any inaccuracies in the filtering model on the final result.



\subsection{Foreground model \label{sec:fg}}

\subsubsection{Thermal dust emission and synchrotron radiation}

The primary diffuse foregrounds in CMB polarization—Galactic thermal dust and synchrotron radiation—possess spectral energy distributions (SEDs) that are distinctly different from the CMB's blackbody spectrum. This spectral distinction is the basis for component separation, which necessitates a minimum of three frequency channels to disentangle the CMB, dust, and synchrotron signals.

The frequency dependence of dust temperature fluctuation is modeled as a modified black-body (MBB) spectrum, which converted to the CMB $\mu$K unit is
\begin{equation}
  W_d(\nu; \nu_{\rm ref}, \beta_d) = \left(\frac{\nu}{\nu_{\rm ref}}\right)^{\beta_d-1}e^{\frac{h(\nu_{\rm ref} - \nu)}{k_BT_{\rm CMB}}}\left(\frac{e^{\frac{h\nu}{k_BT_{\rm CMB}}}-1}{e^{\frac{h\nu_{\rm ref}}{k_BT_{\rm CMB}}}-1}\right)^2 \left(\frac{e^{\frac{h\nu_{\rm ref}}{k_BT_{\rm MBB}}}-1}{e^{\frac{h\nu}{k_BT_{\rm MBB}}}-1}\right), \label{eq:dust_w}
\end{equation}
where $T_{\rm MBB}\approx 20\,\mathrm{K}$ is the effective temperature of MBB spectrum, $T_{\rm CMB}\approx 2.726\,\mathrm{K}$ is the CMB temperature, $\beta_d$ is the frequency spectral index, and $\nu_{\rm ref}$ is an arbitrarily chosen reference frequency. Because thermal dust emission dominates the high-frequency bands, we often choose a high reference frequency, e.g.,  $\nu_{\rm ref,dust} \sim 300\,\mathrm{GHz}$. 

The frequency dependence of synchrotron temperature fluctuation is modeled as a power-law spectrum, which converted to the CMB $\mu$K unit is
\begin{equation}
  W_s(\nu; \nu_{\rm ref}, \beta_s) = \left(\frac{\nu}{\nu_{\rm ref}}\right)^{\beta_s-2}e^{\frac{h(\nu_{\rm ref} - \nu)}{k_BT_{\rm CMB}}}\left(\frac{e^{\frac{h\nu}{k_BT_{\rm CMB}}}-1}{e^{\frac{h\nu_{\rm ref}}{k_BT_{\rm CMB}}}-1}\right)^2, \label{eq:sync_w}
\end{equation}
where  $\beta_s$ is the frequency spectral index, and $\nu_{\rm ref}$ is an arbitrarily chosen reference frequency. Because thermal synchrotron radiation dominates the low-frequency bands, we often choose a low reference frequency, e.g.,  $\nu_{\rm ref,sync} \sim 30\,\mathrm{GHz}$.


When there is no risk of confusion, we may write $W_d(\nu; \nu_{\rm ref}, \beta_d)$ as $W_d(\nu)$, and $W_s(\nu; \nu_{\rm ref}, \beta_d)$ as $W_s(\nu)$. When $\beta_d$ ($\beta_s$) is known, we can convert a dust (synchrotron) map at frequency $\nu_1$ to map at frequency $\nu_2$ with a scaling factor $\frac{W_d(\nu_2)}{W_d(\nu_1)}$ ( $\frac{W_s(\nu_2)}{W_{s,2}}$). (Note that this ratio does not depend on the choice of reference frequency.) Finally, for a frequency band with (normalized) frequency distribution $f(\nu)$, $W_d(\nu)$ should be replaced with averaged weight $\int W_d(\nu) f(\nu)\dsymb\nu$. 

By default DroPS treats the band powers of {\it filtered} dust and synchrotron maps as free parameters. The advantage of doing so is two folds. First, we do not need to worry about the accuracy of $F_{\ell\ell^\prime}$ modeling, as we are directly modeling the band powers of filtered maps. Second, although the average dust/synchrotron power spectra is likely to be smooth, their power spectra in a small sky area may have random ``cosmic variance'', which is taken into account in the free-bandpower parametrization. The disadvantage of abandoning the smoothness assumption on foreground band powers is that it degrades the constraining power on $r$. However, this extra uncertainty is physical, as it correctly reflects that the foreground band powers in a small patch of sky can have random fluctuations around a smooth model.

A blind parametrization of the dust-dust, dust-synchrotron, and synchrotron-synchrotron band powers involves $3n_{\rm fld} n_{\rm bin}+2$ independent parameters. Here $+2$ corresponds to $\beta_d$ and $\beta_s$. Even in the case where only $XY=BB$ is used, the number of foreground parameters is typically $\gtrsim 20$. This poses some challenge to the convergence of Monte Carlo Markov Chain (MCMC) simulations, which is used in DroPS for parameter inference. However, when the data contain a high-frequency channel and a low-frequency channel, which respectively give good ``initial guesses'' of the dust and synchrotron band powers, we empirically find the MCMC runs can reach good convergence.

If the number of available frequency channel is small or the noise is large (target $\sigma_r\gtrsim 0.01$), however, smooth parametrization of foreground power is recommended. The reason is that the ``cosmic variance'' of foreground becomes a tiny effect compared to noise and filter modeling uncertainty. The smooth model of foreground band powers - which is modeled as a quadratic function of $\ell$ - can be turned on in the configuration file by setting analytic\_fg = True.

\subsubsection{Spatially varying foreground: moment expansion method}

The above discussion is based on the assumption of constant $\beta_d$ and $\beta_s$. For experiments that covers a significant portion of the sky, however, it is unlikely that $\beta_d$ ($\beta_s$) will be strictly a constant across a large area of the sky~\cite{Ade25} .  DroPS deals with the spatial variation of foreground spectral indices with moment expansion approximation~\cite{ME} or Taylor expansion methods, which can be switched on by setting freq\_decorr\_model=``ME'' or freq\_decorr\_model=``Taylor'' in the configuration file. Set freq\_decorr\_model=None if strictly constant $\beta_d$ and $\beta_s$ are wanted. By default, DroPS uses the moment expansion method, details of which are given below.

We take thermal dust emission B-mode map for example. At frequency $\nu$, the map is 
\begin{equation}
  B(\nu, \mathbf{n}) = W_d(\nu; \nu_{\rm ref}, \beta_d)B(\nu_{\rm ref}, \mathbf{n}),
\end{equation}
if there were no spatial variation of $\beta_d$. Here $\mathbf{n}$ is the map pixel vector, and $B(\nu_{\rm ref}, \mathbf{n})$ is the map at reference frequency (reference map). Now consider small spatial variation $\delta\beta_d(\mathbf{n})$ and expand to second order of $\delta\beta_d(\mathbf{n})$
\begin{equation}
  B(\nu, \mathbf{n}) = \left\{W_d(\nu; \nu_{\rm ref}, \beta_d) + \frac{\partial W_d}{\partial \beta_d} \delta\beta_d(\mathbf{n}) + \frac{1}{2}\frac{\partial^2 W_d}{\partial \beta_d^2} \left[\delta\beta_d(\mathbf{n})\right]^2\right\}B(\nu_{\rm ref}, \mathbf{n}).  \label{eq:ME_eq1}
\end{equation}
Since $W_d\propto \left(\frac{\nu}{\nu_{\rm ref}}\right)^{\beta_d}$, Eq.~\eqref{eq:ME_eq1} can be explicitly written as
\begin{equation}
  B(\nu, \mathbf{n}) = W_d(\nu; \nu_{\rm ref}, \beta_d) \left\{1 +  \delta\beta_d(\mathbf{n})\ln\frac{\nu}{\nu_{\rm ref}} + \frac{1}{2} \left[\delta\beta_d(\mathbf{n}) \ln\frac{\nu}{\nu_{\rm ref}}\right]^2\right\}B(\nu_{\rm ref}, \mathbf{n}).
\end{equation}


We first consider the full-sky case and do spherical harmonic transform. Assuming $\delta \beta_d(\mathbf{n}) = \sum \beta_{\ell m}Y_{\ell m}(\mathbf{n})$ and $B(\nu, \mathbf{n}) = \sum a_{\ell m}(\nu) Y_{\ell m}(\mathbf{n})$.

\begin{eqnarray}
  a_{\ell m}(\nu) &=& W_d(\nu; \nu_{\rm ref}, \beta_d) \int Y_{\ell m}^*(\mathbf{n})   \left\{1 +  \delta\beta_d(\mathbf{n})\ln\frac{\nu}{\nu_{\rm ref}} + \frac{1}{2} \left[\delta\beta_d(\mathbf{n}) \ln\frac{\nu}{\nu_{\rm ref}}\right]^2\right\}B(\nu_{\rm ref}, \mathbf{n}) \dsymb^2\mathbf{n} \nonumber \\
  &=& W_d(\nu; \nu_{\rm ref}, \beta_d) \left[a_{\ell m}^{\rm ref} +  \ln\frac{\nu}{\nu_{\rm ref}} g_{\ell m}^{\rm ref} +  \left(\ln\frac{\nu}{\nu_{\rm ref}}\right)^2 h_{\ell m}^{\rm ref}\right]
\end{eqnarray}
where
\begin{equation}
  a_{\ell m}^{\rm ref} = a_{\ell m}(\nu_{\rm ref}),
\end{equation}
\begin{equation}
  g_{\ell m}^{\rm ref} = (-1)^m \sqrt{\frac{2\ell+1}{4\pi}}\sum_{\ell_1, m_1, \ell_2, m_2}a_{\ell_1, m_1}^{\rm ref}\beta_{\ell_2, m_2}\sqrt{(2\ell_1+1)(2\ell_2+1)}\begin{pmatrix} \ell_1 & \ell_2 & \ell \\ 0 & 0 & 0 \end{pmatrix}\begin{pmatrix} \ell_1 & \ell_2 & \ell \\ m_1 & m_2 & -m \end{pmatrix},
\end{equation}
and
\begin{small}
\begin{eqnarray}
  h_{\ell m}^{\rm ref} &=&  (-1)^{m}\frac{\sqrt{2\ell+1}}{8\pi}\sum_{\ell_1, m_1, \ell_2,m_2, \ell_3 m_3}a_{\ell_1, m_1}^{\rm ref}\beta_{\ell_2, m_2}\beta_{\ell_3, m_3}\sqrt{(2\ell_1+1)(2\ell_2+1)(2\ell_3+1)} \nonumber \\
  &\times &   \sum_{\ell_4, m_4}(-1)^{m_4}(2\ell_4+1)\begin{pmatrix} \ell_2 & \ell_3 & \ell_4\\ m_2 & m_3 & -m_4 \end{pmatrix}\begin{pmatrix} \ell_2 & \ell_3 & \ell_4 \\ 0 & 0 & 0 \end{pmatrix}\begin{pmatrix} \ell_4 & \ell_1 & \ell \\ 0 & 0 & 0 \end{pmatrix}\begin{pmatrix} \ell_4 & \ell_1 & \ell \\ m_4 & m_1 & -m \end{pmatrix}. \nonumber \\
  \label{eq:hlm1}
\end{eqnarray}
\end{small}

Assuming $\delta \beta_d(\mathbf{n})$ is a random Gaussian field that is uncorrelated with the reference map $B(\nu_{\rm ref}, \mathbf{n})$ and keeping only up to second order of $\delta \beta_d$, we have
\begin{equation}
  \langle (a_{\ell  m}^{\rm ref})^* g_{\ell m}^{\rm ref} \rangle = 0,
\end{equation}
\begin{equation}
  \langle (h_{\ell  m}^{\rm ref})^* g_{\ell m}^{\rm ref} \rangle = 0,
\end{equation}
and
\begin{equation}
 \langle (h_{\ell  m}^{\rm ref})^* h_{\ell m}^{\rm ref} \rangle = 0.
\end{equation}
Here $\langle \cdot \rangle$ represents cosmic expectation value.

Further approximately treating $B(\nu_{\rm ref}, \mathbf{n})$ a random Gaussian field, we may also use the power spectra $C_\ell^{\rm ref} \equiv \langle (a^{\rm ref}_{\ell m})^*a_{\ell m}^{\rm ref} \rangle$ and $S_\ell \equiv \langle (\beta_{\ell m})^*\beta_{\ell m} \rangle$ to express some non-zero expectation values. Specifically, they are
\begin{equation}
  \langle (g_{\ell  m}^{\rm ref})^* g_{\ell m}^{\rm ref} \rangle = \frac{1}{4\pi}\sum_{\ell_1, \ell_2} C_{\ell_1}^{\rm ref}S_{\ell_2}(2\ell_1+1)(2\ell_2+1)\begin{pmatrix} \ell_1 & \ell_2 & \ell \\ 0 & 0 & 0 \end{pmatrix}^2, \label{eq:glmglm}
\end{equation}
and 
\begin{equation}
  \langle (a_{\ell  m}^{\rm ref})^* h_{\ell m}^{\rm ref} \rangle = \frac{1}{8\pi}C_\ell^{\rm ref} \sum_{\ell_2}(2\ell_2+1)S_{\ell_2}. \label{eq:almhlm}
\end{equation}
To derive Eq.~\eqref{eq:glmglm}, we have used the identity
\begin{equation}
  \sum_{m_1, m_2}\begin{pmatrix} \ell_1 & \ell_2 & \ell_3 \\ m_1 & m_2 & m_3 \end{pmatrix} \begin{pmatrix} \ell_1 & \ell_2 & \ell_3^\prime \\ m_1 & m_2 & m_3^\prime \end{pmatrix} = \left\{
  \begin{array}{ll}
    \frac{1}{2\ell_3+1}, & \text{if } |\ell_1-\ell_2| \le \ell_3 \le \ell_1+\ell_2 \text{, } \ell_3 = \ell_3^\prime \text{, } m_3 = m_3^\prime \\
    0, & \text{otherwise}
  \end{array}\right.,
\end{equation}
namely the orthogonal property of 3-$j$ symbol.
To derive Eq.~\eqref{eq:almhlm}, we have used the identity
\begin{equation}
  \sum_{m} (-1)^{\ell - m}
  \begin{pmatrix}
  \ell & \ell & n  \\
  m & -m & 0
  \end{pmatrix}
  = \left\{
  \begin{array}{ll}
    \sqrt{2\ell +1}, &\text{if } n = 0 \\
    0, & \text{else}
  \end{array}
  \right. .
\end{equation}

The power spectrum between two frequency maps $B(\nu, \mathbf{n})$ and $B(\nu^\prime, \mathbf{n})$ is then
\begin{eqnarray}
  C_\ell(\nu, \nu^\prime) &=& \langle a_{\ell m}(\nu) a_{\ell m}(\nu^\prime)\rangle \nonumber \\
  &=& W_d(\nu; \nu_{\rm ref}, \beta_d) W_d(\nu^\prime; \nu_{\rm ref}, \beta_d)\nonumber \\
  && \times \left\{C_\ell^{\rm ref}  +  \langle (g_{\ell  m}^{\rm ref})^* g_{\ell m}^{\rm ref} \rangle \ln\frac{\nu}{\nu_{\rm ref}}\, \ln\frac{\nu^\prime}{\nu_{\rm ref}} +   \langle (a_{\ell  m}^{\rm ref})^* h_{\ell m}^{\rm ref} \rangle \left[\left(\ln\frac{\nu}{\nu_{\rm ref}}\right)^2 + \left(\ln\frac{\nu^\prime}{\nu_{\rm ref}}\right)^2 \right] \right\}. \nonumber \\
  &=& W_d(\nu; \nu_{\rm ref}, \beta_d) W_d(\nu^\prime; \nu_{\rm ref}, \beta_d) \nonumber \\
  && \times \left\{ C_\ell^{\rm ref}\left[1+ \frac{1}{8\pi}\left(\ln^2\frac{\nu}{\nu_{\rm ref}} + \ln^2\frac{\nu^\prime}{\nu_{\rm ref}} \right)\sum_{\ell_2}(2\ell_2+1)S_{\ell_2} \right] \right. \nonumber \\
  && + \left.\frac{1}{4\pi}\ln\frac{\nu}{\nu_{\rm ref}}\, \ln\frac{\nu^\prime}{\nu_{\rm ref}} \sum_{\ell_1, \ell_2} C_{\ell_1}^{\rm ref}S_{\ell_2}(2\ell_1+1)(2\ell_2+1)\begin{pmatrix} \ell_1 & \ell_2 & \ell \\ 0 & 0 & 0 \end{pmatrix}^2  \right\},
\end{eqnarray}



The above result can be written in a more compact way
\begin{equation}
  C_\ell(\nu, \nu^\prime) = W_d(\nu) W_d(\nu^\prime) \left\{ C_\ell^{\rm ref}\left[1+  \mu \left(\ln^2\frac{\nu}{\nu_{\rm ref}} + \ln^2\frac{\nu^\prime}{\nu_{\rm ref}} \right) \right] + \varepsilon_{\ell} \ln\frac{\nu}{\nu_{\rm ref}}\, \ln\frac{\nu^\prime}{\nu_{\rm ref}}\right\}, \label{eq:ME}
\end{equation}
where
\begin{equation}
  \mu \equiv \frac{1}{8\pi}\sum_{\ell_2}(2\ell_2+1)S_{\ell_2} \label{eq:ME_mu}
\end{equation}
is proportional to the variance of $\delta\beta_d$, and
\begin{equation}
  \varepsilon_\ell \equiv \frac{1}{4\pi} \sum_{\ell_1, \ell_2} C_{\ell_1}^{\rm ref}S_{\ell_2}(2\ell_1+1)(2\ell_2+1)\begin{pmatrix} \ell_1 & \ell_2 & \ell \\ 0 & 0 & 0 \end{pmatrix}^2 \label{eq:ME_eps}
\end{equation}
is proportional to the convolution between $\beta_d$ and the reference map.

The minimal parametrization then involve two unknown spectra  $C_\ell^{\rm ref}$ and $S_\ell$, while $\mu$ is a derived parameter that relies on $S_\ell$.


In general we deal with maps in a masked fractional sky. If the variance of $\delta \beta_d$ is dominated by small-scale fluctuations, we may still use Eqs.~(\ref{eq:ME}) as an approximation and replace $S_{\ell_2}$ with $S_{\ell_2}f_{\rm fsky}$ in Eq.~\eqref{eq:ME_mu} and Eq.~\eqref{eq:ME_eps}, where $f_{\rm sky}$ is the sky fraction. However, this approximation may not work very well, for the following reasons.
\begin{enumerate}
\item{Large-scale variation of $\beta_d$ has been observed~\cite{Ade25}, while small-scale variation of $\beta_d$ remains a conjecture. Therefore, it is possible that the variance of $\delta\beta_d$ may be dominated by large-scale modes, whose information is partially missing in a masked sky.}
\item{Similarly, because for masked sky we are dealing with band powers with limited scale coverage, we cannot accurately evaluate the convolution $\varepsilon_\ell$.}
\item{The mask and non-Gaussianity of the dust map may induce coupling between different modes. This will lead to extra scale-dependent contribution to $\mu$ and $\varepsilon_\ell$.}
\end{enumerate}
The net effect is then the relation between $\mu$, $C_\ell^{\rm ref}$  (in form of band powers)  and $S_\ell$  (also in form of band powers) becomes vague in the masked-sky case, and $\mu$ essentially becomes scale-dependent if mode mixing is not negligible. The final model of band powers used in DroPS is then
\begin{equation}
  D_\ell(\nu, \nu^\prime) = W_d(\nu) W_d(\nu^\prime) \left\{ D_\ell^{\rm ref}\left[1+  \mu_\ell \left(\ln^2\frac{\nu}{\nu_{\rm ref}} + \ln^2\frac{\nu^\prime}{\nu_{\rm ref}} \right) \right] + \varepsilon_{\ell} \ln\frac{\nu}{\nu_{\rm ref}}\, \ln\frac{\nu^\prime}{\nu_{\rm ref}}\right\}, \label{eq:ME_ph}
\end{equation}
where $D_{\ell}^{\rm ref}$, $\mu_\ell$ and $\varepsilon_\ell$ (both in form of band powers) are directly taken as independent parameters. To avoid overfitting and consistently keep the $\mu_\ell$ and $\epsilon_\ell$ terms perturbative, we assume an upperbound for $|\mu_\ell|$ and $|\epsilon_\ell|$ (default: $0.05$).

At the time of writing, there is no observational confirmation or rejection of spatial variation of $\beta_d$ on small scales. Eqs.~(\ref{eq:ME_mu},\ref{eq:ME_eps}) imply that $\varepsilon_\ell$ and $\mu_\ell$ are positive parameters, if the extra contribution from mode mixing is negligible. However, applying this physical prior can bias the $r$ measurement if there is actually no spatial variation of $\beta_d$, and we have no clue whether the mode mixing can be safely neglected. Therefore, by default DroPS does not apply the positiveness prior. If wanted, the positiveness prior which can be turned on by setting ME\_is\_positive = True in the configuration file.

The treatment of synchrotron is exactly the same, as the dependence of $W_d$ on $\beta_d$ and $W_s$ on $\beta_s$ is identical ($W_d\propto (\nu/\nu_{\rm ref})^{\beta_d}$ and $W_s\propto (\nu/\nu_{\rm ref})^{\beta_s}$).

In summary, we have generalized the moment expansion method to masked sky, but still have ignored many complexities that may emerge in reality, such as possible correlation between $\delta \beta_d$, $\delta\beta_s$ and the reference map. Although some of the complexities may be absorbed into the free parameters $\mu_\ell$ and $\varepsilon_\ell$, we do not expect Eq.~\eqref{eq:ME_ph} covers all possible degrees of freedom. Nevertheless, at least for small perturbations around the base (constant-SED) model, moment expansion method is a good tool to account for the foreground complexity.

\subsubsection{Frequency decorrelation: Talor expansion method}



For the base (constant-SED) model of dust (synchrotron), the band powers satisfy $\left[D_\ell(\nu, \nu^\prime)\right]^2 = D_\ell(\nu, \nu) D_\ell(\nu^\prime, \nu^\prime)$. Complexity of foreground such as spatial variation of SED in general weakens the correlation between different frequency maps, that is,
\begin{equation}
  \left[D_\ell(\nu, \nu^\prime)\right]^2 \le D_\ell(\nu, \nu) D_\ell(\nu^\prime, \nu^\prime), \label{eq:decorr_ineq}
\end{equation}
with equality if and only if $\nu=\nu^\prime$.

Note that, however, the moment expansion formula Eq.~\eqref{eq:ME_ph} (or the full-sky version Eq.~\eqref{eq:ME}) does not explicitly follow this physically motivated inequality. Motivated by the inequality~\eqref{eq:decorr_ineq}, DroPS provides a phenomenological model, which can be turned on by setting fg\_decorr\_model = ``Taylor'' in the configuration file. The idea of this model is to Taylor expand the spectral index $\beta_d$ in the $\nu,\ell$ space. Specifically, the band powers of dust in is parameterized as
\begin{equation}
  D_\ell(\nu, \nu^\prime) = W_d(\nu; \nu_{\rm ref}, \beta_d + \delta\beta_{d, \ell} + \gamma_d \frac{\nu}{\nu_{\rm ref}})W_d(\nu^\prime; \nu_{\rm ref},\beta_d + \delta\beta_{d, \ell} + \gamma_d\frac{\nu^\prime}{\nu_{\rm ref}})\exp{\left[-\frac{\ln^2\frac{\nu}{\nu^\prime}}{Q_\ell}\right]} D_\ell^{\rm ref},
\end{equation}
where $\beta_d$ and $\gamma_d$ are the average SED and the frequency running of SED; $D_\ell^{\rm ref}$ is the reference band power;  $\delta\beta_{d, \ell}$ describes the variation of $\beta_d$ in $\ell$ space;  $Q_\ell>0$ describes the logarithm spacing of frequency decorrelation. (Frequency decorrelation is significant if $\ln\frac{\nu}{\nu^\prime} \gtrsim Q_\ell$.)



\begin{figure}
  \includegraphics[width=\textwidth]{method_compare.png}
  \caption{Comparison between base model (None), moment expansion method (ME) and Taylor expansion method (Taylor).\label{fig:compare_methods}}
\end{figure}

The moment expansion and Taylor expansion methods typically induce shifts of $r$ on the order of a few $\times 10^{−4}$. We use the more precise demo-experiment SO to highlight the impact of foreground modeling. Figure~\ref{fig:compare_methods} compares the reconstructed $r$ using the base model (constant SED), the moment expansion, and the Taylor expansion methods. Each data point and error bar represent the mean and standard deviation, respectively, averaged over 250 random realizations of the "observed sky." Our analysis shows that the moment expansion method remains nearly unbiased across all tested scenarios, albeit at the cost of a modest increase in uncertainty. The Taylor expansion method also performs robustly in the presence of foreground frequency decorrelation. However, in the absence of such decorrelation, it tends to systematically underestimate the value of $r$.

\subsection{Covariance matrix of band powers \label{sec:cov}}

While the covariance matrix of the band powers could, in principle, be estimated directly from simulations, this approach faces a practical challenge: the covariance matrix typically contains over a thousand free elements, which cannot be robustly constrained by the few hundred simulations typically available. To overcome this, DroPS implements a two-step stabilization procedure: it applies ``noise cleaning'' by neglecting noise correlations across different channels or observation seasons, and enforces ``scale separation'' by ignoring correlations between widely separated multipole bins.

DroPS decomposes the covariance matrix into three components: the noise covariance, the signal covariance, and the signal$\times$noise covariance. The advantage of doing so is that noise covariance can be ``cleaned'' with the prior knowledge that noise in different frequency channels (or observation seasons) are uncorrelated. DroPS also assumes that the noise $T$, $E$, $B$ are mutually uncorrelated\footnote{In the default settings where $BB$ band powers are used, this assumption is not used.}. Consequently, the noise covariance between $D^{XY}_\ell(\nu_1,\nu_2)$ and $D^{X^\prime Y^\prime}_{\ell^\prime}(\nu_1^\prime,\nu_2^\prime)$ is nonzero only if $XY=X^\prime Y^\prime$ and $(\nu_1, \nu_2) = (\nu_1^\prime, \nu_2^\prime)$. This substantially reduces the degrees of freedom and improves the accuracy of noise covariance estimation.


By default, DroPS assumes no correlation between different multipole bins (ell\_cross\_range = 0 in the configuration file). Optionally, it can model correlations between adjacent (ell\_cross\_range = 1) or next-to-adjacent bins (ell\_cross\_range = 2). However, simply truncating the covariance matrix to these limited off-diagonal blocks can violate its positive-definite property, introducing unphysical "ghost modes" with negative eigenvalues that lead to catastrophic overfitting. To balance information retention with numerical stability, DroPS applies suppression factors to the off-diagonal $\ell$ blocks. The optimal factors, listed in Table~\ref{tab:sup_mat}, are derived analytically for a small number of bins or numerically for a larger set. Specifically:
\begin{itemize}
  \item{For ell\_cross\_range = 1, the first off-diagonal blocks are multiplied by a factor $f_1$.}
  \item{For ell\_cross\_range = 2, the first and second off-diagonal blocks are multiplied by factors $f_1$​ and $f_2$​, respectively.}
\end{itemize}
        
\begin{table}
  \centering
  \caption{suppression factors ($f_1$ for adjacent and $f_2$ for next-to-adjacent bins) \label{tab:sup_mat}}
  \begin{tabular}{lll}
    \hline
    \hline
    & ell\_cross\_range = 1 &  ell\_cross\_range = 2  \\
    \hline
    \# $\ell$ bins &  $f_1$ & $f_1, f_2$ \\
    \hline
    $2$ & $1$ &  - \\
    $3$ & $\frac{1}{\sqrt{2}}$ & $1$, $1$ \\
    $4$ & $\frac{\sqrt{5}-1}{2}$ & $\frac{\sqrt{3}}{2}$, $\frac{1}{2}$ \\
    $5$ & $\frac{1}{\sqrt{3}}$ & $\sqrt{2-\sqrt{\frac{28}{3}}\cos\frac{\pi+\arccos\sqrt{\frac{27}{28}}}{3}}$, $\sqrt{\frac{28}{3}}\cos\frac{\pi+\arccos\sqrt{\frac{27}{28}}}{3}-1$ \\
    $6$ & $\frac{2}{3} -\frac{\sqrt{28}}{3}\cos\frac{\pi+\arccos\frac{1}{\sqrt{28}}}{3}$ & $\sqrt{\frac{3}{2}-\frac{4\sqrt{7}}{9}\cos\frac{\pi-\arccos\frac{17}{7\sqrt{7}}}{3} + \frac{7}{9}\cos\frac{2\pi-2\arccos\frac{17}{7\sqrt{7}}}{3}}$, \\ %$\sqrt{1-\left(\frac{5}{3} - \frac{2\sqrt{7}}{3}\cos\frac{\pi-\arccos\frac{17}{7\sqrt{7}}}{3}\right)\left(\frac{1}{6} + \frac{\sqrt{7}}{3}\cos\frac{\pi-\arccos\frac{17}{7\sqrt{7}}}{3}\right)}$, \\
    & & $\frac{5}{6} - \frac{\sqrt{7}}{3}\cos\frac{\pi-\arccos\frac{17}{7\sqrt{7}}}{3}$ \\
    $7$ & $\frac{\sqrt{2-\sqrt{2}}}{2}$ & $0.74222720$ ,  $0.25777280$ \\
    $8$  & $0.53208889$ & $0.74535599$ ,  $\frac{1}{3}$ \\
    $9$  & $0.52573111$ & $0.73967857$ ,  $0.29430138$ \\
    $10$ & $0.52110856$ & $0.73205081$ ,  $0.26794919$ \\
    $11$ & $0.51763809$ & $0.72458926$ ,  $0.24925315$ \\
    $12$ & $0.51496392$ & $0.72430917$ ,  $0.29789426$ \\
    $13$ & $0.51285843$ & $0.72360680$ ,  $0.27639320$ \\
    $14$ & $0.51117030$ & $0.72095982$ ,  $0.25989153$ \\
    $15$ & $0.50979558$ & $0.71754959$ ,  $0.24694521$ \\
    $16$ & $0.50866092$ & $0.71688142$ ,  $0.28311858$ \\
    $17$ & $0.50771331$ & $0.71707895$ ,  $0.26835006$ \\
    $18$ & $0.50691364$ & $0.71592096$ ,  $0.25627141$ \\
    $19$ & $0.50623256$ & $0.71404546$ ,  $0.24626867$ \\
    $20$ & $0.50564767$ & $0.71340854$ ,  $0.27515189$ \\
    $\infty$ & $\frac{1}{2}$ & $\frac{1}{\sqrt{2}}$, $\frac{1}{4}$ \\
    \hline
  \end{tabular}
\end{table}

Empirical tests show that the correlations between adjacent $\ell$ bins and next-to-adjacent $\ell$ bins usually do not have a significant impact on the constraint on $r$ and foreground parameters. Figure~\ref{fig:ell_cross_range} shows an example. The simulation is done with AliCPT/AliCPT\_sim\_config.txt with fiducial $r=0.01$ and random seed 5; the analyses are done with AliCPT/AliCPT\_ana\_config.txt (with ell\_cross\_range = 0, 1, 2 respectively). The input fiducial $r=0.01$ and $\beta_d=1.54$ are marked with lightgray dotted lines in the figure. The contours are plotted with the script utils/plot\_cont.py that comes with DroPS.

\begin{figure}
  \centering
  \includegraphics[width=0.6\textwidth]{AliCPT_ell_cross_range.png}
  \caption{Impact of the correlations between adjacent $\ell$ bins and next-to-adjacent $\ell$ bins\label{fig:ell_cross_range}}
\end{figure}


The signal and signal$\times$noise covariance matrices are cosmology-dependent. DroPS pre-computes them at the two fiducial points, $r=0$ and $r=r_1$​, from the base simulations. Within the interval $0<r<r_1$, the covariances are interpolated according to their known scaling with $r$: the signal covariance scales with $r^2$ and is thus interpolated linearly in $r^2$, while the signal$\times$noise covariance scales with $r$ and is interpolated linearly in $r$. For values $|r|>r_1$​, DroPS uses the covariance evaluated at $r=r_1$​, deliberately avoiding any extrapolation to prevent the introduction of unphysical modes and catastrophic overfitting.


\subsection{Component separation \label{sec:sgld_like}}

For map-level component separation, the likelihood  $\mathcal{L}\propto e^{-\chi^2/2}$ is constructed under a Gaussian noise model, where
\begin{equation}
  \chi^2 = v_{\rm noise}^TN^{-1}v_{\rm noise},
\end{equation}
Here, $v_{\rm noise}$ represents the noise frequency maps, and $N$ is their covariance matrix. In pixel space, the dimension of $v_{\rm noise}$​ is $n_{\rm pix} n_\nu$, which for experiments like AliCPT or SO-SAT with $\gtrsim 10\%$ sky coverage typically exceeds $10^4$. This makes the covariance matrix $N$, with $10^8$ elements, prohibitively large to estimate robustly from simulations and to invert efficiently.

To overcome this, the BICEP/Keck analysis~\cite{BKmap} adopts a diagonal approximation of $N$ in pixel space, considering only pixel auto-correlations. DroPS employs a more accurate approximation by assuming $N$ is diagonal in harmonic space. This approach better captures the correlations inherent in the data while remaining computationally tractable.

We label a pixel with index $j$ ($j=1, 2, \ldots, n_{\rm pix}$), and frequency channels with index $k$ ($k = 1, 2, \ldots, n_\nu$). The CMB maps are identical in all frequency channels, and are modeled as
\begin{equation}
  (Q\pm \mathrm{i}U)_{\rm CMB, j, k} = -\sum_{\ell = 0}^{\ell_{\max}}\sum_{m=-\ell}^\ell (c_{\ell m}^E\pm \mathrm{i} c_{\ell m}^B)\;_{\pm 2}Y_{\ell m}(\mathbf{n}_j), \label{eq:CMB_comp}
\end{equation}
where $\mathbf{n}_j$ is the directional vector of the $j$-th pixel. The expansion bases $_{\pm 2}Y_{\ell m}$ are spin-weighted spherical harmonics. Note that here $c_{\ell m}^E$ and $c_{\ell m}^B$ are harmonic coefficients of the full-sky CMB map. Degeneracy between these parameters are expected for partial sky observations. 

Due to limited frequency resolution, BICEP/Keck analysis models the foreground maps ($v_{\rm FG}$) as a single component (thermal dust). DroPS takes a more accurate two-component model with emission from Galactic synchrotron and thermal dust. The dust maps are modeled as
\begin{equation}
  (Q\pm \mathrm{i}U)_{\rm dust, j, k} =  -\int W_d(\nu) f_k(\nu) \dsymb\nu \,\sum_{\ell = 0}^{\ell_{\max}}\sum_{m=-\ell}^\ell (d_{\ell m}^E\pm \mathrm{i}  d_{\ell m}^B)\;_{\pm 2}Y_{\ell m}(\mathbf{n}_j),  \label{eq:dust_comp}
\end{equation}
where the frequency dependence function $W_d$ is defined in Eq.~\eqref{eq:dust_w} and $f_k(\nu)$ is the frequency distribution of the $k$-th frequency channel.
Synchrotron maps are modeled similarly,
\begin{equation}
  (Q\pm \mathrm{i}U)_{\rm sync, j, k} =  -\int W_s(\nu) f_k(\nu) \dsymb\nu \,\sum_{\ell = 0}^{\ell_{\max}}\sum_{m=-\ell}^\ell (s_{\ell m}^E\pm \mathrm{i}  s_{\ell m}^B)\;_{\pm 2}Y_{\ell m}(\mathbf{n}_j),  \label{eq:sync_comp}
\end{equation}
where $W_s$ is given in Eq.~\eqref{eq:sync_w}.

The sky model $(Q+iU)_{\rm sky}$ is the sum of Eqs.~(\ref{eq:CMB_comp}, \ref{eq:dust_comp}, \ref{eq:sync_comp}). Passing the sky model through the TOD filtering and map making process, we obtain the filtered sky maps. Subtracting the filtered sky maps from the observed (filtered) maps, we obtain filtered noise maps in pixel space. To compute the likelihood, we decompose the noise maps into harmonic space,
\begin{equation}
   M_j(Q\pm \mathrm{i}U)_{\rm noise, filtered, j, k} = -\sum_{\ell = 0}^{\ell_{\max}}\sum_{m=-\ell}^\ell (\tilde{n}_{\ell m}^E\pm \mathrm{i} \tilde{n}_{\ell m}^B)\;_{\pm 2}Y_{\ell m}(\mathbf{n}_j).
\end{equation}
Here $M_j$ is pixel value of a smoothed mask, whose edges are apodized using a C2-type kernel  with an apodization scale of 2 degrees~\cite{Grain09}.  The purpose of introducing such a smoothed mask is to suppress unphysical modes due to sharp-edge and to reduce $E$-to-$B$ leakage.

On the other hand, we can calculate $\tilde{n}_{\ell m}^E$ and $\tilde{n}_{\ell m}^B$ from the filtered noise maps in the base simulations, and compute their diagonal covariance $\tilde{N}^E_{\ell m} \equiv \langle |\tilde{n}_{\ell m}^E|^2\rangle $ and $\tilde{N}^B_{\ell m} \equiv \langle |\tilde{n}_{\ell m}^B|^2\rangle $. For most mask shapes, the $m$-dependencies of $\tilde{N}^E_{\ell m} \equiv \langle |\tilde{n}_{\ell m}^E|^2\rangle$ and $\tilde{N}^B_{\ell m} \equiv \langle |\tilde{n}_{\ell m}^E|^2\rangle$ are very weak, and mostly reflect the statistic fluctuations due to finite sampling. Therefore, DroPS uses the $m$-averaged pseudo power spectra $\tilde{N}_\ell^E$ and $\tilde{N}_\ell^B$ to construct the likelihood in harmonic space. The likelihood $\propto e^{-\chi^2/2}$ is given by
\begin{equation}
  \chi^2 = f_{\rm sky}\sum_{\ell = 0}^{\ell_{\max}} \sum_{m=-\ell}^\ell \frac{|\tilde{n}_{\ell m}|^2}{N_{\ell}}.
\end{equation}



\bibliographystyle{unsrt}
\bibliography{refs} 

\end{document}



